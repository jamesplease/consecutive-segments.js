{"version":3,"sources":["consecutive-segments.js"],"names":[],"mappings":"WAAU,IAAI,EAAE,OAAO,EAAE;AACvB;AACE;;AAEA;AACA;AACA;;AAEA;;EAEH,iBAAiB,CAAC,EAAE,MAAM,EAAE;AAC3B;;;AAMA,MAAI,mBAAmB,GAAG,UAAS,QAAQ,EAAiB;QAAf,KAAK,gCAAC,OAAO;AACxD,QAAI,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;AAAE,aAAO,EAAE,CAAC;KAAE;;AAEvC;QAAsB,aAAa,YAAA;QAAE,UAAU,YAAA,CAAC;AAChD,WAAO,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CACrB,GAAG,CAAC,UAAC,MAAM,EAAE,SAAS,EAAK;AAC1B,aAAO,EAAE,SAAS,EAAT,SAAS,EAAE,MAAM,EAAN,MAAM,EAAE,CAAC;KAC9B,CAAC,kBACO,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,QAAQ,EAAK;;;;;AAMpC,UAAI,KAAK,EAAE;AACT,qBAAa,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,GAAG,EAAE,CAAC;AAC/C,kBAAU,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,GAAG,EAAE,CAAC;AAC9D,YAAI,aAAa,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,GAAG,CAAC,EAAE;AAC7C,sBAAY,EAAE,CAAC;SAChB;OACF;;;AAGD,UAAI,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE;AACvB,YAAI,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC;OACzB;AACD,UAAI,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC,aAAO,IAAI,CAAC;KACb,EAAE,EAAE,CAAC,CACL,KAAK,EAAE,CAAC;GACZ,CAAC;;;;;AAKF,SAAO,mBAAmB,CAAC;CAC5B,CAAC,CAAC","file":"consecutive-segments.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['underscore', 'moment'], factory);\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore');\n    var moment = require('moment');\n    module.exports = factory(_, moment);\n  } else {\n    root.consecutiveSegments = factory(root._, root.moment);\n  }\n})(this, function(_, moment) {\n  'use strict';\n\n  import _ from 'underscore';\n  import moment from 'moment';\n  \n  // Segment an array of events by scale\n  var consecutiveSegments = function(segments, scale='weeks') {\n    if (_.isEmpty(segments)) { return []; }\n  \n    let currentGroup = 0, currentMoment, prevMoment;\n    return _.chain(segments)\n      .map((events, timestamp) => {\n        return { timestamp, events };\n      })\n      .reduce((memo, s, index, segments) => {\n  \n        // Check to see if the current group is the same\n        // as the previous group by computing the difference\n        // in their timestamps. They aren't consecutive when\n        // the difference is > 1\n        if (index) {\n          currentMoment = moment.unix(s.timestamp).utc();\n          prevMoment = moment.unix(segments[index - 1].timestamp).utc();\n          if (currentMoment.diff(prevMoment, scale) > 1) {\n            currentGroup++;\n          }\n        }\n  \n        // Ensure that the group exists, then push to it\n        if (!memo[currentGroup]) {\n          memo[currentGroup] = [];\n        }\n        memo[currentGroup].push(_.clone(s));\n        return memo;\n      }, [])\n      .value();\n  };\n  \n  export default consecutiveSegments;\n  \n  \n  return consecutiveSegments;\n});\n"],"sourceRoot":"/source/"}