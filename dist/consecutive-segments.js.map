{"version":3,"sources":["consecutive-segments.js"],"names":[],"mappings":"WAAU,IAAI,EAAE,OAAO,EAAE;AACvB;AACE;;AAEA;AACA;AACA;;AAEA;;EAEH,iBAAiB,CAAC,EAAE,MAAM,EAAE;AAC3B;;AAWA,MAAI,mBAAmB,GAAG;;;AAGxB,SAAK,EAAA,eAAC,QAAQ,EAAiB;UAAf,KAAK,gCAAC,OAAO;AAC3B,UAAI,YAAY,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;;AAEpC,UAAI,CAAC,QAAQ,IAAI,YAAY,KAAK,CAAC,EAAE;AACnC,eAAO,EAAE,CAAC;OACX;;AAED,UAAI,YAAY,GAAG,CAAC,EAAE,MAAM,GAAG,EAAE,EAAE,aAAa,EAAE,UAAU,CAAC;AAC7D,OAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CACd,GAAG,CAAC,UAAC,MAAM,EAAE,SAAS,EAAK;AAC1B,eAAO,EAAE,SAAS,EAAT,SAAS,EAAE,MAAM,EAAN,MAAM,EAAE,CAAC;OAC9B,CAAC,CACD,IAAI,CAAC,UAAC,CAAC,EAAE,KAAK,EAAE,QAAQ,EAAK;;;;;AAM5B,YAAI,KAAK,KAAK,CAAC,EAAE;AACf,uBAAa,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,GAAG,EAAE,CAAC;AAC/C,oBAAU,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,GAAG,EAAE,CAAC;AAC9D,cAAI,aAAa,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,GAAG,CAAC,EAAE;AAC7C,wBAAY,EAAE,CAAC;WAChB;SACF;;;AAGD,YAAI,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE;AACzB,gBAAM,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC;SAC3B;AACD,cAAM,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;OACvC,CAAC,CAAC;;AAEL,aAAO,MAAM,CAAC;KACf;GACF,CAAC;;;;;AAKF,SAAO,mBAAmB,CAAC;CAC5B,CAAC,CAAC","file":"consecutive-segments.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['underscore', 'moment'], factory);\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore');\n    var moment = require('moment');\n    module.exports = factory(_, moment);\n  } else {\n    root.ConsecutiveSegments = factory(root._, root.moment);\n  }\n})(this, function(_, moment) {\n  'use strict';\n\n  // Place your library's code here\n  //\n  // If you add additional files, be sure to\n  // load them in order in ./wrapper.js\n  //\n  \n  import _ from 'underscore';\n  import moment from 'moment';\n  \n  var ConsecutiveSegments = {\n  \n    // Segment an array of events by scale\n    group(segments, scale='weeks') {\n      var segmentCount = _.size(segments);\n  \n      if (!segments || segmentCount === 0) {\n        return [];\n      }\n  \n      var currentGroup = 0, groups = [], currentMoment, prevMoment;\n      _.chain(segments)\n        .map((events, timestamp) => {\n          return { timestamp, events };\n        })\n        .each((s, index, segments) => {\n  \n          // Check to see if the current group is the same\n          // as the previous group by computing the difference\n          // in their timestamps. > 1 means that they aren't\n          // consecutive.\n          if (index !== 0) {\n            currentMoment = moment.unix(s.timestamp).utc();\n            prevMoment = moment.unix(segments[index - 1].timestamp).utc();\n            if (currentMoment.diff(prevMoment, scale) > 1) {\n              currentGroup++;\n            }\n          }\n  \n          // Ensure that the group exists, then push to it\n          if (!groups[currentGroup]) {\n            groups[currentGroup] = [];\n          }\n          groups[currentGroup].push(_.clone(s));\n        });\n  \n      return groups;\n    }\n  };\n  \n  export default ConsecutiveSegments;\n  \n  \n  return ConsecutiveSegments;\n});\n"],"sourceRoot":"/source/"}