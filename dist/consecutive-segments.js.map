{"version":3,"sources":["consecutive-segments.js"],"names":[],"mappings":"WAAU,IAAI,EAAE,OAAO,EAAE;AACvB;AACE;;AAEA;AACA;AACA;;AAEA;;EAEH,iBAAiB,CAAC,EAAE,MAAM,EAAE;AAC3B;;AAWA,MAAI,mBAAmB,GAAG;;;AAGxB,SAAK,EAAA,eAAC,QAAQ,EAAiB;UAAf,KAAK,gCAAC,OAAO;AAC3B,UAAI,YAAY,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC;;AAE3C,UAAI,CAAC,QAAQ,IAAI,YAAY,KAAK,CAAC,EAAE;AACnC,eAAO,EAAE,CAAC;OACX;;;AAGD,cAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,QAAQ,EAAE,UAAC,OAAO,EAAE,SAAS,EAAK;AACjD,eAAO,EAAE,SAAS,EAAT,SAAS,EAAE,OAAO,EAAP,OAAO,EAAE,CAAC;OAC/B,CAAC,CAAC;;AAEH,UAAI,MAAM,GAAG,EAAE,EAAE,aAAa,EAAE,UAAU,CAAC;AAC3C,UAAI,YAAY,GAAG,CAAC,CAAC;AACrB,OAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,UAAC,CAAC,EAAE,KAAK,EAAK;;;AAI7B,YAAI,KAAK,KAAK,CAAC,EAAE;AACf,uBAAa,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,GAAG,EAAE,CAAC;AAC/C,oBAAU,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,GAAG,EAAE,CAAC;AAC9D,cAAI,aAAa,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,GAAG,CAAC,EAAE;AAC7C,wBAAY,EAAE,CAAC;WAChB;SACF;;;AAGD,YAAI,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE;AACzB,gBAAM,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC;SAC3B;AACD,cAAM,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;OAC9B,CAAC,CAAC;;AAEH,aAAO,MAAM,CAAC;KACf;GACF,CAAC;;;;;AAKF,SAAO,mBAAmB,CAAC;CAC5B,CAAC,CAAC","file":"consecutive-segments.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['underscore', 'moment'], factory);\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore');\n    var moment = require('moment');\n    module.exports = factory(_, moment);\n  } else {\n    root.ConsecutiveSegments = factory(root._, root.moment);\n  }\n})(this, function(_, moment) {\n  'use strict';\n\n  // Place your library's code here\n  //\n  // If you add additional files, be sure to\n  // load them in order in ./wrapper.js\n  //\n  \n  import _ from 'underscore';\n  import moment from 'moment';\n  \n  var ConsecutiveSegments = {\n  \n    // Segment an array of events by scale\n    group(segments, scale='weeks') {\n      var segmentCount = _.keys(segments).length;\n  \n      if (!segments || segmentCount === 0) {\n        return [];\n      }\n  \n      // Convert the objects into arrays for comparing\n      segments = _.map(segments, (segment, timestamp) => {\n        return { timestamp, segment };\n      });\n  \n      var groups = [], currentMoment, prevMoment;\n      var currentGroup = 0;\n      _.each(segments, (s, index) => {\n  \n        // Check to see if the current group is the same\n        // as the previous group by comparing\n        if (index !== 0) {\n          currentMoment = moment.unix(s.timestamp).utc();\n          prevMoment = moment.unix(segments[index - 1].timestamp).utc();\n          if (currentMoment.diff(prevMoment, scale) > 1) {\n            currentGroup++;\n          }\n        }\n  \n        // Ensure that the group exists, then push to it\n        if (!groups[currentGroup]) {\n          groups[currentGroup] = [];\n        }\n        groups[currentGroup].push(s);\n      });\n  \n      return groups;\n    }\n  };\n  \n  export default ConsecutiveSegments;\n  \n  \n  return ConsecutiveSegments;\n});\n"],"sourceRoot":"/source/"}